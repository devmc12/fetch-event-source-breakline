{
  "version": 3,
  "sources": ["../src/parse.ts", "../src/fetch.ts"],
  "sourcesContent": ["/**\r\n * Represents a message sent in an event stream\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\r\n */\r\nexport interface EventSourceMessage {\r\n    /** The event ID to set the EventSource object's last event ID value. */\r\n    id: string;\r\n    /** A string identifying the type of event described. */\r\n    event: string;\r\n    /** The event data */\r\n    data: string;\r\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\r\n    retry?: number;\r\n}\r\n\r\n/**\r\n * Converts a ReadableStream into a callback pattern.\r\n * @param stream The input ReadableStream.\r\n * @param onChunk A function that will be called on each new byte chunk in the stream.\r\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\r\n */\r\nexport async function getBytes(stream: ReadableStream<Uint8Array>, onChunk: (arr: Uint8Array) => void) {\r\n    const reader = stream.getReader();\r\n    let result: ReadableStreamDefaultReadResult<Uint8Array>;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\n\r\nconst enum ControlChars {\r\n    NewLine = 10,\r\n    CarriageReturn = 13,\r\n    Space = 32,\r\n    Colon = 58,\r\n}\r\n\r\n/**\r\n * Parses arbitary byte chunks into EventSource line buffers.\r\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\r\n * @param onLine A function that will be called on each new EventSource line.\r\n * @returns A function that should be called for each incoming byte chunk.\r\n */\r\nexport function getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\r\n    let buffer: Uint8Array | undefined;\r\n    let position: number; // current read position\r\n    let fieldLength: number; // length of the `field` portion of the line\r\n    let discardTrailingNewline = false;\r\n\r\n    // return a function that can process each incoming byte chunk:\r\n    return function onChunk(arr: Uint8Array) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        } else {\r\n            // we're still parsing the old line. Append the new bytes into buffer:\r\n            buffer = concat(buffer, arr);\r\n        }\r\n\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0; // index where the current line starts\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === ControlChars.NewLine) {\r\n                    lineStart = ++position; // skip to next char\r\n                }\r\n\r\n                discardTrailingNewline = false;\r\n            }\r\n\r\n            // start looking forward till the end of line:\r\n            let lineEnd = -1; // index of the \\r or \\n char\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case ControlChars.Colon:\r\n                        if (fieldLength === -1) { // first colon in line\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\r\n                    case ControlChars.CarriageReturn:\r\n                        discardTrailingNewline = true;\r\n                    case ControlChars.NewLine:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (lineEnd === -1) {\r\n                // We reached the end of the buffer but the line hasn't ended.\r\n                // Wait for the next arr and then continue parsing:\r\n                break;\r\n            }\r\n\r\n            // we've reached the line end, send it out:\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position; // we're now on the next line\r\n            fieldLength = -1;\r\n        }\r\n\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined; // we've finished reading it\r\n        } else if (lineStart !== 0) {\r\n            // Create a new view into buffer beginning at lineStart so we don't\r\n            // need to copy over the previous lines when we get the new arr:\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    }\r\n}\r\n\r\n// \u4E0A\u4E00\u6761\u4FDD\u5B58\u7684\u884C\uFF08\u5904\u7406data: xxxx \\n bbbb \u6362\u884C\u7684\u60C5\u51B5\uFF09\r\nlet savedLine: string | null = null;\r\n\r\n/**\r\n * Parses line buffers into EventSourceMessages.\r\n * @param onId A function that will be called on each `id` field.\r\n * @param onRetry A function that will be called on each `retry` field.\r\n * @param onMessage A function that will be called on each message.\r\n * @returns A function that should be called for each incoming line buffer.\r\n */\r\nexport function getMessages(\r\n    onId: (id: string) => void,\r\n    onRetry: (retry: number) => void,\r\n    onMessage?: (msg: EventSourceMessage) => void\r\n) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n\r\n    // return a function that can process each incoming line buffer:\r\n    return function onLine(line: Uint8Array, fieldLength: number) {\r\n        if (line.length === 0) {\r\n            // empty line denotes end of message. Trigger the callback and start a new message:\r\n            onMessage?.(message);\r\n            message = newMessage();\r\n            savedLine = null; // \u6E05\u9664\u4FDD\u5B58\u7684\u884C\r\n        } else if (fieldLength > 0) { // exclude comments and lines with no values\r\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\r\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n\r\n            // \u5904\u7406\u4EE5 { \u5F00\u5934\u4F46\u4E0D\u662F } \u7ED3\u5C3E\u7684\u60C5\u51B5\r\n            if (value.startsWith(\"{\") && !value.endsWith(\"}\")) {\r\n                savedLine = value;\r\n                onMessage?.(message);\r\n                message = newMessage();\r\n                return;\r\n            }\r\n\r\n            switch (field) {\r\n                case 'data':\r\n                    // if this message already has data, append the new value to the old.\r\n                    // otherwise, just set to the new value:\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value; // otherwise, \r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) { // per spec, ignore non-integers\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n                default:\r\n                    // \u5408\u5E76\u4E0A\u4E00\u6761\u4FDD\u5B58\u7684 value\r\n                    if (savedLine) {\r\n                        message.data = (message.data ? message.data + '\\n' : '') + savedLine + field  + \":\" + value;\r\n                        savedLine = null;\r\n                    } else {\r\n                        savedLine = null;\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction concat(a: Uint8Array, b: Uint8Array) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\n\r\nfunction newMessage(): EventSourceMessage {\r\n    // data, event, and id must be initialized to empty strings:\r\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\r\n    // retry should be initialized to undefined so we return a consistent shape\r\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n", "import { EventSourceMessage, getBytes, getLines, getMessages } from './parse';\r\n\r\nexport const EventStreamContentType = 'text/event-stream';\r\n\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\n\r\nexport interface FetchEventSourceInit extends RequestInit {\r\n    /**\r\n     * The request headers. FetchEventSource only supports the Record<string,string> format.\r\n     */\r\n    headers?: Record<string, string>,\r\n\r\n    /**\r\n     * Called when a response is received. Use this to validate that the response\r\n     * actually matches what you expect (and throw if it doesn't.) If not provided,\r\n     * will default to a basic validation to ensure the content-type is text/event-stream.\r\n     */\r\n    onopen?: (response: Response) => Promise<void>,\r\n\r\n    /**\r\n     * Called when a message is received. NOTE: Unlike the default browser\r\n     * EventSource.onmessage, this callback is called for _all_ events,\r\n     * even ones with a custom `event` field.\r\n     */\r\n    onmessage?: (ev: EventSourceMessage) => void;\r\n\r\n    /**\r\n     * Called when a response finishes. If you don't expect the server to kill\r\n     * the connection, you can throw an exception here and retry using onerror.\r\n     */\r\n    onclose?: () => void;\r\n\r\n    /**\r\n     * Called when there is any error making the request / processing messages /\r\n     * handling callbacks etc. Use this to control the retry strategy: if the\r\n     * error is fatal, rethrow the error inside the callback to stop the entire\r\n     * operation. Otherwise, you can return an interval (in milliseconds) after\r\n     * which the request will automatically retry (with the last-event-id).\r\n     * If this callback is not specified, or it returns undefined, fetchEventSource\r\n     * will treat every error as retriable and will try again after 1 second.\r\n     */\r\n    onerror?: (err: any) => number | null | undefined | void,\r\n\r\n    /**\r\n     * If true, will keep the request open even if the document is hidden.\r\n     * By default, fetchEventSource will close the request and reopen it\r\n     * automatically when the document becomes visible again.\r\n     */\r\n    openWhenHidden?: boolean;\r\n\r\n    /** The Fetch function to use. Defaults to window.fetch */\r\n    fetch?: typeof fetch;\r\n}\r\n\r\nexport function fetchEventSource(input: RequestInfo, {\r\n    signal: inputSignal,\r\n    headers: inputHeaders,\r\n    onopen: inputOnOpen,\r\n    onmessage,\r\n    onclose,\r\n    onerror,\r\n    openWhenHidden,\r\n    fetch: inputFetch,\r\n    ...rest\r\n}: FetchEventSourceInit) {\r\n    return new Promise<void>((resolve, reject) => {\r\n        // make a copy of the input headers since we may modify it below:\r\n        const headers = { ...inputHeaders };\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n\r\n        let curRequestController: AbortController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort(); // close existing request on every visibility change\r\n            if (!document.hidden) {\r\n                create(); // page is now visible again, recreate request.\r\n            }\r\n        }\r\n\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n\r\n        // if the incoming signal aborts, dispose resources and resolve:\r\n        inputSignal?.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve(); // don't waste time constructing/logging errors\r\n        });\r\n\r\n        const fetch = inputFetch ?? window.fetch;\r\n        const onopen = inputOnOpen ?? defaultOnOpen;\r\n        async function create() {\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, {\r\n                    ...rest,\r\n                    headers,\r\n                    signal: curRequestController.signal,\r\n                });\r\n\r\n                await onopen(response);\r\n                \r\n                await getBytes(response.body!, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        // store the id and send it back on the next retry:\r\n                        headers[LastEventId] = id;\r\n                    } else {\r\n                        // don't send the last-event-id header anymore:\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n\r\n                onclose?.();\r\n                dispose();\r\n                resolve();\r\n            } catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    // if we haven't aborted the request ourselves:\r\n                    try {\r\n                        // check if we need to retry:\r\n                        const interval: any = onerror?.(err) ?? retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    } catch (innerErr) {\r\n                        // we should not retry anymore:\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        create();\r\n    });\r\n}\r\n\r\nfunction defaultOnOpen(response: Response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!contentType?.startsWith(EventStreamContentType)) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
